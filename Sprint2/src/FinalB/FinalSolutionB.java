/*
    ИД отправки в Яндекс.Контест - 49127987
 */

/*
    ---ОПИСАНИЕ РЕШЕНИЯ---

    Решение состоит из нескольких основных частей

        1) Интерпретатора выражения, заданного обратной польской нотацией.
        2) Интерпретатора элементарной бинарной операции

    ---АЛГОРИТМ ИНТЕРПРЕТАЦИИ ВЫРАЖЕНИЯ---

    Интерпретатор выражения, заданный обратной польской нотацией, обеспечивает парсинг (вычленение из входной строки )
    элементарных бинарных функций и представление входной строки в виде композиции элементарных бинарных функций:
        P(x,y,z,...) = Fn(...., F1(z, F0(y,x))...)

    Поскольку рассматривается модель композиции, то результат выполнения любой предыдущей в цепочке вызова функции
    является  аргументом для последующей.

    Поскольку знак операции в обратной польской нотации стоит после аргументов, то алгоритм парсинга последовательно
    зачитывает токены (подстроки) из входной строки выражения, записывая их во временный буфер (стэк), вплоть до
    ближайшего токена операции. Токеном операции является строка единичной длины, которая включает в себя один символ
    из заданного конечного множества значений: {"+", "-", "*", "/"}.

    Как только будет найден токен операции, производится интерпретация и вычисление значения
    элементарной бинарной функции, которое также запиывается с буфер аргументов (см. далее).

    Интерпретация и вычисление элементарной бинарной функции может идти по одному из 2-х вариантов:
        1) оба аргумента функции явлются числами. В этом случае данные числа были зачитаны
            ранее и находятся в буфере аргументов.
        2) один из аргументов функции является результатом вычисления вложенной функции, а другой - число.
            В этом случае оба аргумента также находятся в буфере аргументов (стэке), так как результаты вычисление
            предыдущей функции были помещены в стэк после вычисления, а после этого было произведено дополнительное
            зачитывние из строки второго аргумента.

    Извлечение аргументов производится по протоколу LIFO, чтобы обеспечить соответствие порядка аргументов исходному.

    По результатам обработки всей цепочки вложенных функций, итоговый результат будет единственным числом,
    оставшимся в стэке. Его оттуда извлекает функция интерпретации выражения и возвращает в качестве результата
    интерпретации и вычисления.

    ---ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ АЛГОРИТМА ИНТЕРПРЕТАЦИИ ВЫРАЖЕНИЯ---

    Общий контекст вычисления выражения не выходит за пределы контекста вычисления бинарной функции Fn, в силу заданной
    модели: P(x,y,z,...) = Fn(...., F1(z, F0(y,x))...). Таким образом в контексте вычисления всегда находятся только 2
    аргумента. Результат вычисления каждой функции помещается в контекст вычисления последующей функции.

    Согласно правилам обратной польской нотации:
    1) Аргументом функции может быть либо число, либо результат вычисления вложенной функции.
        Таким образом в контексте вычисления всегда не более 2-х аргементов.
    2) Правее аргументов функции всегда находится либо токен операции, либо конец строки.

    Таким образом последовательное (слева направо) зачитывание и интерпретация токенов в один проход решает задачу
    вычисления выражения в целом. Результат последней (самой правой) элементарной операции останется в контексте
    вычислений (стэке) по достижению конца входной строки выражения.

    ---ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА ИНТЕРПРЕТАЦИИ ВЫРАЖЕНИЯ---
    1) Зачитывание n токенов  = О(n)
    2) Проверка, что подстрока является токеном операции = О(1)
    3) Парсинг токена в операнд (число) = О(1) [считаем, что токены операндов одинаковой длины]
    4) Помещение операндов в контекст вычислений (стэк) = О(1)
    5) Зачитывание операндов из контекста вычислений (стэка) = О(1)
    6) Интерпретация выражения = О(1) [см. далее]

    ИТОГО: O(n) + n*O(1)+ n*O(1)+ (2n/3)*O(1) + (2n/3) *O(1)+(n/3)*O(1) = O(n) + O(n) + O(n) + 2*O(2n/3) + O(n/3) = O(n)

    Примечания:
    1) максимальное количество элементарных бинарных функций = n/3,
    2) максимальное количество аргументов элементарных бинарных функций = 2n/3

    ---ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА---
    Контекст вычилений состоит:
     1) Временные переменные = O(1)
     2) Переменные состояния функции интерпретации элементарной бинарной функции = O(1)
     3) стэк с контекстом вычислений, который содержит не более 2-х элементов = 2*О(1) = О(2)

     ИТОГО: О(1) + О(1) + О(2) = О(1)

    ---АЛГОРИТМ ИНТЕРПРЕТАЦИИ ЭЛЕМЕНТАРНОЙ БИНАРНОЙ ФУНКЦИИ---

    Интерпретации производится путем сравнения токена операции с заданным набором вариантов  {"+", "-", "*", "/"},
    каждому из которых сопоставлена соответствующая бинарная операция. Соответствие является однозначным и с малой
    вариативностью, поэтому вычисляется каскадом условных операторов.

    ---ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА ИНТЕРПРЕТАЦИИ ЭЛЕМЕНТАРНОЙ БИНАРНОЙ ФУНКЦИИ---
    1) Определение вида операции = 4*О(1) = O(4)
    2) Выполнения элементарной бинарной операции = О(1)

    ИТОГО: O(4) + О(1) = О(1)

    ---ПРОСТРАНЕСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА ИНТЕРПРЕТАЦИИ ЭЛЕМЕНТАРНОЙ БИНАРНОЙ ФУНКЦИИ---
    Функция не содержит состояния, только копии входных параметров и выходное значение. Поэтому значение
    пространственной сложности составляет О(1).

    ИТОГО: О(1)


    ---ИТОГОВЫЙ РАСЧЕТ ПО ПРОГРАММЕ В ЦЕЛОМ---
    Временная сложность программы в целом соответствут временной сложности
    алгоритма интерпретации выражения = O(n), где n - количество токенов в строке выражения.

    Пространственная сложность программы в целом соответствут пространственной сложности
    алгоритма интерпретации выражения = O(1).

 */

package FinalB; // эту строку нужно закомментировать перед отправкой в Яндекс.Контест

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;
import java.util.StringTokenizer;

/**
 * Основной класс решения
 */
public class FinalSolutionB {
    /**
     * Функция интерпретации и вычисления операции
     * @param operandOne    Операнд №1
     * @param operandTwo    Операнд №2
     * @param operation     Знак операции {"+", "-", "*", "/"}
     * @return Целочисленный результат вычисления
     */
    private static int ProcessOperation(int operandOne, int operandTwo, char operation) {
        if (operation == '+') return operandOne + operandTwo;
        if (operation == '-') return operandOne - operandTwo;
        if (operation == '*') return operandOne * operandTwo;
        if (operation == '/') return Math.floorDiv(operandOne, operandTwo);
        return 0;
    }

    /**
     * Функция проверки, является ли токен (подсрока) знаком операции {"+", "-", "*", "/"}
     * @param token Входной токен (подстрока)
     * @return  Истина (является знаком операции) / Ложь
     */
    private static boolean isOperator(String token) {
        char firstChar = token.charAt(0);
        return (token.length() == 1) && ((firstChar == '+') || (firstChar == '-') || (firstChar == '*') || (firstChar == '/'));
    }

    /**
     * Функция интерпретации арифметического выражения, заданного строкой
     * @param input Входная строка с арифметическим выражением, заданным обратной польской нотацией
     * @return Целочисленный результат вычисления
     */
    public static int Calculate(String input) {
        Stack<Integer> context = new Stack<>();
        StringTokenizer tokenizer = new StringTokenizer(input);

        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();

            if (isOperator(token)) {
                char operation = token.charAt(0);
                int operand2 = context.pop(); // поддержка протокола LIFO
                int operand1 = context.pop(); // поддержка протокола LIFO
                context.push(ProcessOperation(operand1, operand2, operation));
            } else {
                context.push(Integer.parseInt(token));
            }

        }
        return context.pop();
    }

    /**
     * Точка входа в программу
     * @param args  Параметры коммандной строки (для целей совместимости)
     * @throws IOException Функция может выбрасывать исключение ввода/вывода.
     */
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(String.valueOf(Calculate(reader.readLine())));
    }
}
