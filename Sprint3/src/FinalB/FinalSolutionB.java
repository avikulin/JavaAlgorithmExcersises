/*
    Кот отправки в Яндекс.Контест - 50462981
 */

package FinalB; //--эту строку нужно закомментировать перед отправкой в Яндекс. Контест.

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringJoiner;
import java.util.StringTokenizer;

/*
    ОПИСАНИЕ РЕШЕНИЯ

    Решение построено на базе следующих компонентов:

    1) Класс "Participant", реализующий функции упорядоченного множества участников соревнований. Класс содержит операцию
       порядка "compareTo", реализованную в соответствии с условиями задачи: сначала сортируем по убыванию баллов, потом по
       возрастанию штрафов, потом по возрастанию лексикографически.

    2) Класс "ScoreTable" реализующий работу с турнирной таблицей:
     - регистрацию счета участников ("appendParticipant");
     - упорядочивание участников в соответствии с условиями задачи ("sort")
     - вывод результатов упорядочивания  ("printList")
     - вспомогательные функции сортировки ("doPartitionSequence" и "swap")

    ОПИСАНИЕ АЛГОРИТМОВ

    Алгоритм сортировки состоит из следующих основных частей:
    1) Функция сравнения пары элементов согласно условию задачи.
    2) Функция разделения последовательности на упорядоченные подпоследовательности
    3) Функция рекурсивного вызова п.2 для полученных подпоследовательностей.
    4) Функция вывода упорядоченной последовательности.

    Алгоритм п.1 реализован в классе "Participant" в реализации интерфейса упорядоченных множеств "Comparable".

    Алгоритмы п. 2 реализован следующим образом (подсмотрено у Дж. Кормена):
    1) во входящей последовательности выбирается разрешающий элемент. Поскольки последовательность случайна -
       то разрешающим элементом выбирается всегда последний элемент.
    2) последовательность разделяетмя на 3 подпоследовательности в зависимости от отношения порядка с
        разрешающим элементом:
        - меньшая подпоследовательность (lesserSubSequence). Содержит элементы строго меньшие разрешающего.
        - большая подпоследовательность. Содержит элементы большие, либо равные разрешающему. Начинается со следующего
          элемента за границей меньшей подпоследовательности.
        - эквивалентная подпоследовательность. Вложена в большую подпоследовательность и содержит элементы,
          эквивалентные разрешающему. Выделение данной подпоследовательности происходит в п. 3.

       Алгоритм разделения на непересекающиеся подпоследовательности (верхнеуровнево):
       А) устанавливаем указательно не границу (правую) меньшей подпоследовательности за пределами левой границы входящей
       последовательности.
       Б) устанавливаем указатель на разрешающий элемент - последний элемент входящей последовательности.
       В) в цикле просматриваем все элементы входящей последовательности, кроме конечного (разрешающего):
            В1)  сравниваем текущий элемент с разрешающим.
            В1.1) если текущий элемент меньше разрешающего, двигаем указатель правой границы меньшей
                  подпоследовательности на одну позицию вправо и меняем местами (swap) текущий элемент и элемент,
                  на который указывет указатель правой границы (lesserSubSequence). Таким образом текущий элемент
                  перемещается в меньшую подпоследовательность.
      Г) Меняем местами разрешающий элемент с первым элементом большей подпоследовательности. Теперь разрешающий элемент
         входит в нее.
      Д) возвращаем индекс разрешающего элемента.

    3) разрешающий элемент устанавливается первым элементом большей подпоследовательности (в начале он был последним
        элементом входящей последовательности)
    4) возвращаем указатель (позицию во входящей последовательности) разрешающего элемента. Таким образом после
       выполнения вышеописанных пунктов меньшая подпоследовательность зажата междут первым элементом и разрешающим
       элементом (может быть пустой), а большая подпоследовательность зажата между разрешающим и последним элементом
       последовательности (также может быть пустой).

                указатель на     указатель на
    границу (правую) меньшей     границу (левую) большей
       подпоследовательности     подпоследовательности
                            \    /
                             |  |       указатель на текущий (в цикле)
                             |  |       элемент последовательности
                             |  |        |
            A [ (. . . . . . .)(. . . . <.> . . . . .)(X)]
                |             ||                   |   ^
                |             ||   { Ai >= X }     |   |
                |             ||                   |    \
                |             |                          указатель на
                |             |                          разрешающий элемент
                |             |
                |             |
                |             |
                | { Ai < X }  |

      Алгоритм п.3 рекурсивно выполняет следующие шаги для входной последовательности:
    1) разделение входной последовательности на большую и меньшую подпоследовательности (левее и правее разрешающего
        элемента).
    2) выделяет из большей подпоследовательности эквивалентную подпоследовательность путем последовательного сравнения
       ее элементов с разрешающим.
    3) если меньшая подпоследовательность содержит более одного элемента, то рекурсивно вызываем алгоритм п.3 для нее
       (рекуррентный случай). Если последовательность пуста, или содержит только один элемент (базовый случай) - выходим
       из алгоритма.

    Алгоритм п.4 заключается в последовательном выводе элементов последовательности в цикле.

    ОЦЕНКА ВРЕМЕННОЙ СЛОЖНОСТИ

    Алгоритм п.1 = O(1)
                                             установка разрешающего элемента первым в большую последовательность
                                            /
    Алгоритм п.2 = (n-1)*O(1) + m*O(1) + O(1) = O(n), где:
                                                    (n-1) - количество операций сравнения элементов,
                                                     m - количество операций перестановки элементов
                                            ! причем m < (n-1)

    Алгоритм п.3. Худший случай (все значения входной последовательности в обратном порядке)
    Алгоритм п.3 = O(1) + O(k) + p*O(p) = O(p^2)    где:
                     |                                   n - количество членов входной последовательности
                     |                                   k - количество членов эквивалентной подпоследовательности
                     |                                   p - количество членов большей подпоследовательности
                     |                       ! причем    n = 1 + k + p
                    /
      пустая меньшая
      подпоследовательность

      При (к==1) временная сложность составит O(n^2) в худшем случае.

      Алгоритм п.3. Обычнй (regular) случай (значения входной последовательности находятся в случайном порядке)
       на каждом шаге рекурсии = O(l) + O(k) + O(p) где
                                                          l - количество членов меньшей подпоследовательности
                                                          k - количество членов эквивалентной подпоследовательности
                                                          p - количество членов большей подпоследовательности
                                                          ! причем    n = l + k + p

      Если взять (k==1), а оценки длины большей и меньшей подпоследовательностей сделать исходя из равномерного
      распределения величин элементов во входной последовательности l,p = (n-1)/2, то общая временная сложность
      составит O(n*log(n)).

      ОЦЕНКА ПРОСТРАНСТВЕННОЙ СЛОЖНОСТИ АЛГОРИТМА

      Алгоритм п.1 = O(1)
      Алгоритм п.2 = O(1), так как не создаются новые структуры в памяти, за исключением временных скалярных переменных.
      Алгоритм п.3 = O(1), так как не создаются новые структуры в памяти, за исключением временных скалярных переменных.

      ЗАМЕЧАНИЕ. В расчете пространственной сложности алгоритма п.3 не учтено потребление памяти стеком вызовов при
      многократной рекурсивной обработке входной последовательности. Предполгается, что в стеке присутствуют только
      адрес возврата (8 байт) и два целочисленных параметра параметра (8 байт), что совокупно представляет собой 32
      байта памяти. Таким образом потребление памяти стеком можно оценить как O(32*log(n)). При размере входной
      последовательности много большим 32, данным значением можно пренебречь.
 */

/**
 * Класс инкапсулирует элементы множества участников соревнований
 */
class Participant implements Comparable<Participant> {
    private String personalLogin;
    private Integer scoreValue;
    private Integer penaltyValue;

    /**
     * Конструктор элемента множества участников
     *
     * @param login   Имя учетной записи участника соревнований
     * @param score   Значение счета (количества решенных задач)
     * @param penalty Значение штрафа
     */
    Participant(String login, Integer score, Integer penalty) {
        personalLogin = login;
        scoreValue = score;
        penaltyValue = penalty;
    }

    /**
     * Возвращает имя учетной записи элемента
     *
     * @return
     */
    String getLogin() {
        return personalLogin;
    }

    /**
     * Задает отношение (больше / меньше / равно) двух элементов множества
     *
     * @param other Ссылка на сравниваемый элемент
     * @return 0 - если элементы равны,
     * 1 - если сравниваемый элемент больше текущего,
     * (-1) - если сравниваемый элемент меньше текущего.
     */
    @Override
    public int compareTo(Participant other) {
        if (!scoreValue.equals(other.scoreValue))
            return scoreValue > other.scoreValue ? -1 : 1; // сортировка по убыванию

        if (!penaltyValue.equals(other.penaltyValue))
            return penaltyValue < other.penaltyValue ? -1 : 1; // сортировка по убыванию

        return personalLogin.compareTo(other.personalLogin); // сортировка по возрастанию
    }
}

/**
 * Класс инкапсулирует функционал турнирной таблицы
 */
class ScoreTable {
    private Participant[] scoresStorage;
    private boolean sortedState;
    private int stackHeadPointer;

    /**
     * Конструктор экземпляра турнирной таблицы
     *
     * @param numberOfParticipants
     */
    ScoreTable(int numberOfParticipants) {
        scoresStorage = new Participant[numberOfParticipants];
        stackHeadPointer = -1;
        sortedState = false;
    }

    /**
     * Добавление записи участника в турнирную таблицу
     *
     * @param participant Ссылка на экземпляр участника соревнований
     */
    public void appendParticipant(Participant participant) {
        sortedState = false;
        stackHeadPointer++;
        scoresStorage[stackHeadPointer] = participant;
    }

    /**
     * Вывод упорядоченных (начиная с первого места) значений турнирной таблицы
     *
     * @return Текстовое представление турнирной таблцы (каждый участник на отдельной строке)
     */
    public String printList() {
        if (stackHeadPointer == -1) return "";

        if (!sortedState) {
            sort(0, stackHeadPointer);
            sortedState = true;
        }

        StringJoiner joiner = new StringJoiner("\n", "", "");
        for (int i = 0; i <= stackHeadPointer; i++)
            joiner.add(scoresStorage[i].getLogin());

        return joiner.toString();
    }

    /**
     * Перестановка двух элементов множества участников
     *
     * @param firstIdx  Индекс первого элемента
     * @param secondIdx Индекс второго элемента
     */
    private void swap(int firstIdx, int secondIdx) {
        if (firstIdx == secondIdx) return;

        Participant temp = scoresStorage[firstIdx];
        scoresStorage[firstIdx] = scoresStorage[secondIdx];
        scoresStorage[secondIdx] = temp;
    }

    /**
     * Разделение последовательности участников соревнований (scoresStorage) на меньшую и большую подпостедовательности
     * относительно разрешающего (последнего).
     *
     * @param leftBoundIdx  Индекс первого элемента последовательности (scoresStorage)
     * @param rightBoundIdx Индекс последнего элемента последовательности (scoresStorage)
     * @return Индекс разрешающего элемента в обработанной последовательности
     */
    private int doPartitionSequence(int leftBoundIdx, int rightBoundIdx) {
        int lesserSubSequenceBound = leftBoundIdx - 1;
        int pivotElementPointer = rightBoundIdx;

        for (int currentElementPointer = leftBoundIdx;
             currentElementPointer < rightBoundIdx;
             currentElementPointer++) {
            if (scoresStorage[currentElementPointer].compareTo(scoresStorage[pivotElementPointer]) < 0) {
                lesserSubSequenceBound++;
                swap(lesserSubSequenceBound, currentElementPointer);
            }
        }

        swap(lesserSubSequenceBound + 1, pivotElementPointer);

        return lesserSubSequenceBound + 1;
    }

    /**
     * Сортировка последовательности участников соревнований
     *
     * @param leftBoundIdx  Индекс первого элемента последовательности
     * @param rightBoundIdx Индекс последнего элемента последовательности
     */
    private void sort(int leftBoundIdx, int rightBoundIdx) {
        if (rightBoundIdx == leftBoundIdx) return; // не сортируем последовательности из одного элемента

        int pivotElement = doPartitionSequence(leftBoundIdx, rightBoundIdx);

        if (leftBoundIdx < pivotElement) // если меньшая подпоследовательность не пуста
            sort(leftBoundIdx, pivotElement - 1);

        while (pivotElement < rightBoundIdx) { // выделение эквивалетной подпоследовательности из большей
            if (scoresStorage[pivotElement].equals(scoresStorage[pivotElement + 1]))
                pivotElement++;
            else
                break; // просмотр ведется до первого неэквивалентного элемента.
        }

        if (pivotElement < rightBoundIdx)// если большая подпоследовательность не пуста
            sort(pivotElement + 1, rightBoundIdx);
    }
}

/**
 * Основной класс программы
 */
public class FinalSolutionB {
    /**
     * Базовая функция обработки входных данных
     *
     * @param input Входная последовательность записей участников соревнований
     * @return Текстовое представление результатов обработки
     */
    public static String process(String[] input) {
        int numberOfParticipants = Integer.parseInt(input[0]);
        ScoreTable table = new ScoreTable(numberOfParticipants);

        for (int i = 1; i < numberOfParticipants + 1; i++) {
            StringTokenizer tokenizer = new StringTokenizer(input[i]);
            String login = tokenizer.nextToken();
            int score = Integer.parseInt(tokenizer.nextToken());
            int penalty = Integer.parseInt(tokenizer.nextToken());
            table.appendParticipant(new Participant(login, score, penalty));
        }

        return table.printList();
    }

    /**
     * Точка входа в программу.
     * Зачитывание входных данных из консоли.
     * Вывод результатов работы программы в консоль.
     *
     * @param args Параметры командной строки (для целей совместимости)
     * @throws IOException Может выбрасываться исключение ввода/вывода.
     */
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int numberOfParticipantRecords = Integer.parseInt(reader.readLine());
        String[] buffer = new String[numberOfParticipantRecords + 1];
        buffer[0] = String.valueOf(numberOfParticipantRecords);
        for (int i = 1; i < numberOfParticipantRecords + 1; i++)
            buffer[i] = reader.readLine();

        System.out.println(process(buffer));
    }
}
