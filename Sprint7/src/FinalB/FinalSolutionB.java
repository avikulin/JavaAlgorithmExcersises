// код посылки в Яндекс.Контест - 54020498

package FinalB; //закомментировать перед отправкой

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
        Решаем задачу аналогично задаче о рюкзаке: если у нас сумма всех элементов S, то нам нужно определить, сможем ли
        мы собрать рюкзак массой S/2. Само собой, если S нечетно - то можно сразу вернуть "False".

        Рассмотрим на примере №1 из задачи.

        Даны элементы {1, 5, 7, 1}, S= 1 + 5 + 7 + 1 = 14 (четно). Нам нужно набрать сумму 7.

        Решаем задачу динамически:

        рассматриваем подмножества, образованные добавление следующего элемента: {}, {1}, {1,5}, {1,5,7}, {1,5,7,1}
        и проверяем, можно ли набрать заданную сумму включением или исключением последнего элемента. Заданная сумма
        меняется от 0 до S/2.

        ОБЩЕЕ РЕШЕНИЕ:

        0) Базовый случай:
            - сумму 0 можно набрать любым подмножеством, исключая все его элементы.
            - пустым подмножеством нельзя набрать никакую сумму, кроме нуля.

        1) Функция перехода: DP[i, s] = DP[i-1,s]||DP[i-1,S/2 - s]. Следовательно DP[i, s] = true в одном из случаев:

            а) Если заданную сумму можно набрать не включая последний элемент, значит она уже набрана на предыдущей
                итерации, т.е. элемент (i-1,s)=true.

            б) Если заданную сумму можно набрать включая последний элемент, значит на предыдушей итерации мы должны были
                набрать сумму (S/2-s) без использования данного элемента, т.е. (i-1,S/2 - s)=true.

            Оптимизация:
              - Если элемент  (i-1,s)=true, то вариант б) можно не рассматривать, а сразу присвоить true.

              - Если последний элемент подмножества, соответствующего строке i, больше соотвествующего значения s, то
                вариант б) можно не рассматривать.

            Если хотя бы один из вариантов дает true, значит мы можем набрать заданную сумму с использованием элементов
            данного подмножества. Поэтому в данному случае элементу (i, s) присваивается значение true.

            Поскольку каждый элемент каждого подмножества проверяется на включение/исключение, значит
            мы обрабатываем все возможные варианты 2^(n*S/2).

        2) Хранение состояния обеспечивается в таблице (n, S/2), где каждая строка соответствует инкрементному
            подмножеству элементов, а каждый столбец - целевой сумме.

                                       s
                          ┌──────────────────────────────▷
                          │  0   1   2   3   4   5   6   7              Условные обозначения:
                   {}     |  t   f   f   f   f   f   f   f              't' = true
                  {1}   i |  t   t   f   f   f   f   f   f              'f' = false
                {1,5}     |  t   t   f   f   f   t   t   f
              {1,5,7}     |  t   t   f   f   f   t   t   t
            {1,5,7,1}     ▽  t   t   t   f   f   t   t  [t] <-- результат вычислений

        3) Поскольку функция перехода задана рекурсивно (i-1,S/2 - s) -> (i,s), то вычисления выполняются от левого
            верхнего угла к правому нижнему.

        4) Результат работы алгоритма будет соответствовать элементу (n, S/2).

        ОПТИМИЗАЦИЯ ОБЩЕГО РЕШЕНИЯ:

        Для оптимизации расхода памяти, мы будем хранить только (i-1) строку, обновляя ее соответствующим значением
        i-ой строки. Чтобы не было пересечения в обновляемых значениях между итерациями - изменим порядок вычислений:
        теперь двигаемся S/2 -> S(i), при этом увеличивая i в штатном порядке от 0 до n.

        При таком подходе коллизий между итерациями не будет.

        ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА: O(n*S/2)
        ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМА: O(S/2)
 */

public class FinalSolutionB {
    public static String process(String[] input) {
        int numElements = Integer.parseInt(input[0]);

        if (numElements < 2) return "False";

        int[] elements = new int[numElements];
        int sum = 0;
        StringTokenizer tokenizer = new StringTokenizer(input[1]);
        for (int i = 0; i < numElements; i++) {
            elements[i] = Integer.parseInt(tokenizer.nextToken());
            sum += elements[i];
        }

        if (sum % 2 == 1) return "False";

        sum = sum / 2; // сразу приведем сумму к целевому виду

        boolean[] dpCache = new boolean[sum + 1];
        dpCache[0] = true;

        for (int i = 0; i < numElements; i++) {
            int currentSum = elements[i];
            for (int s = sum; s >= currentSum; s--) {
                boolean dpCaseWithout = dpCache[s];
                boolean dpCaseWith = dpCache[s - currentSum];
                if (dpCaseWith || dpCaseWithout) {
                    dpCache[s] = true; // не тратим время на обновления массива, если ничего не поменялось.
                }
            }
        }
        return dpCache[sum] ? "True" : "False";
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] buffer = new String[2];
        buffer[0] = reader.readLine();
        buffer[1] = reader.readLine();
        System.out.println(process(buffer));
    }
}
